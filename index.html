<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klotski Puzzle (Hardcoded Solution)</title>
    <style>
        /* CSS remains the same as before */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            background-color: #f0f0f0;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #klotski-board {
            position: relative;
            width: 400px; /* unitSize * boardWidth */
            height: 500px; /* unitSize * boardHeight */
            border: 2px solid #333;
            background-color: #eee;
            margin-bottom: 20px;
            overflow: hidden; /* Prevents blocks going outside visually */
        }

        .block {
            position: absolute;
            box-sizing: border-box;
            border: 1px solid #666;
            background-color: #b0c4de; /* Light steel blue */
            cursor: pointer;
            transition: top 0.2s ease-in-out, left 0.2s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            user-select: none; /* Prevent text selection on drag attempts */
        }

        .block-1x1 { width: 100px; height: 100px; background-color: #f4a460; /* Sandy brown */}
        .block-1x2 { width: 100px; height: 200px; background-color: #add8e6; /* Light blue */ }
        .block-2x1 { width: 200px; height: 100px; background-color: #90ee90; /* Light green */ }
        .block-2x2 {
            width: 200px;
            height: 200px;
            background-color: #ff6347; /* Tomato red */
            font-size: 18px;
            border: 2px solid #a00;
        }
        .block-target {
             background-color: #ff4500; /* OrangeRed - Highlight target */
             border: 3px solid black;
        }

        #controls button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        #status {
            margin-top: 10px;
            font-size: 1em;
            color: #333;
            min-height: 1.2em; /* Reserve space */
        }
    </style>
</head>
<body>

<h1>Klotski Puzzle (Huarong Dao - Hardcoded Solution)</h1>

<div id="game-container">
    <div id="klotski-board">
        </div>
    <div id="controls">
        <button id="solve-reset-button">Show Solution</button>
    </div>
    <div id="status">Click a block to move it or show the hardcoded solution.</div>
</div>

<script>
    const boardWidth = 4;
    const boardHeight = 5;
    const unitSize = 100; // px
    const targetBlockId = 'block-1'; // The 2x2 block ('Cao Cao')
    const targetWinX = 1;
    const targetWinY = 3; // Target position (0-indexed)

    // Standard Huarong Dao initial layout
    const initialBlocks = [
        { id: 'block-0', x: 0, y: 0, w: 1, h: 2, name: 'Zhang Fei' },
        { id: 'block-1', x: 1, y: 0, w: 2, h: 2, name: 'Cao Cao', isTarget: true },
        { id: 'block-2', x: 3, y: 0, w: 1, h: 2, name: 'Ma Chao' },
        { id: 'block-3', x: 0, y: 2, w: 1, h: 2, name: 'Zhao Yun' },
        { id: 'block-4', x: 1, y: 2, w: 2, h: 1, name: 'Guan Yu' },
        { id: 'block-5', x: 3, y: 2, w: 1, h: 2, name: 'Huang Zhong' },
        { id: 'block-6', x: 1, y: 3, w: 1, h: 1, name: 'Soldier' },
        { id: 'block-7', x: 2, y: 3, w: 1, h: 1, name: 'Soldier' },
        { id: 'block-8', x: 0, y: 4, w: 1, h: 1, name: 'Soldier' },
        { id: 'block-9', x: 3, y: 4, w: 1, h: 1, name: 'Soldier' },
    ];

    // --- HARDCODED SOLUTION PATH ---
    // Full 81-step optimal solution for standard Huarong Dao layout
    // Each object represents one move: { blockId: 'id_of_block_to_move', dx: change_in_x, dy: change_in_y }
    // dx=1 (right), dx=-1 (left), dy=1 (down), dy=-1 (up)
    const hardcodedSolutionPath = [
        { blockId: 'block-6', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-7', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-4', dx: 0, dy: 1 },  // Guan Yu Down
        { blockId: 'block-1', dx: 0, dy: 1 },  // Cao Cao Down
        { blockId: 'block-0', dx: 1, dy: 0 },  // Zhang Fei Right
        { blockId: 'block-3', dx: 1, dy: 0 },  // Zhao Yun Right
        { blockId: 'block-8', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-6', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-4', dx: 0, dy: -1 }, // Guan Yu Up
        { blockId: 'block-7', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-9', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-5', dx: -1, dy: 0 }, // Huang Zhong Left
        { blockId: 'block-2', dx: -1, dy: 0 }, // Ma Chao Left
        { blockId: 'block-7', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-9', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-5', dx: 0, dy: -1 }, // Huang Zhong Up
        { blockId: 'block-2', dx: 0, dy: 1 },  // Ma Chao Down
        { blockId: 'block-7', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-4', dx: 0, dy: 1 },  // Guan Yu Down
        { blockId: 'block-6', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-3', dx: 0, dy: -1 }, // Zhao Yun Up
        { blockId: 'block-0', dx: 0, dy: 1 },  // Zhang Fei Down
        { blockId: 'block-8', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-6', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-4', dx: -1, dy: 0 }, // Guan Yu Left
        { blockId: 'block-1', dx: 0, dy: -1 }, // Cao Cao Up
        { blockId: 'block-7', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-9', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-5', dx: 0, dy: 1 },  // Huang Zhong Down
        { blockId: 'block-2', dx: 0, dy: -1 }, // Ma Chao Up
        { blockId: 'block-7', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-9', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-5', dx: -1, dy: 0 }, // Huang Zhong Left
        { blockId: 'block-4', dx: 0, dy: -1 }, // Guan Yu Up
        { blockId: 'block-6', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-8', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-0', dx: 0, dy: -1 }, // Zhang Fei Up
        { blockId: 'block-3', dx: 1, dy: 0 },  // Zhao Yun Right
        { blockId: 'block-1', dx: -1, dy: 0 }, // Cao Cao Left
        { blockId: 'block-4', dx: 1, dy: 0 },  // Guan Yu Right
        { blockId: 'block-6', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-8', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-0', dx: 0, dy: 1 },  // Zhang Fei Down
        { blockId: 'block-3', dx: 0, dy: 1 },  // Zhao Yun Down
        { blockId: 'block-6', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-4', dx: 0, dy: 1 },  // Guan Yu Down
        { blockId: 'block-1', dx: 0, dy: -1 }, // Cao Cao Up
        { blockId: 'block-3', dx: 0, dy: -1 }, // Zhao Yun Up
        { blockId: 'block-0', dx: 1, dy: 0 },  // Zhang Fei Right
        { blockId: 'block-8', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-6', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-3', dx: -1, dy: 0 }, // Zhao Yun Left
        { blockId: 'block-0', dx: 0, dy: -1 }, // Zhang Fei Up
        { blockId: 'block-8', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-6', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-4', dx: -1, dy: 0 }, // Guan Yu Left
        { blockId: 'block-1', dx: 0, dy: 1 },  // Cao Cao Down
        { blockId: 'block-7', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-9', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-5', dx: 1, dy: 0 },  // Huang Zhong Right
        { blockId: 'block-2', dx: 0, dy: 1 },  // Ma Chao Down
        { blockId: 'block-9', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-7', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-1', dx: 1, dy: 0 },  // Cao Cao Right
        { blockId: 'block-4', dx: 0, dy: -1 }, // Guan Yu Up
        { blockId: 'block-6', dx: 0, dy: -1 }, // Soldier Up
        { blockId: 'block-3', dx: 1, dy: 0 },  // Zhao Yun Right
        { blockId: 'block-0', dx: -1, dy: 0 }, // Zhang Fei Left
        { blockId: 'block-8', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-6', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-4', dx: 0, dy: 1 },  // Guan Yu Down
        { blockId: 'block-1', dx: 0, dy: -1 }, // Cao Cao Up
        { blockId: 'block-7', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-9', dx: 1, dy: 0 },  // Soldier Right
        { blockId: 'block-5', dx: 0, dy: -1 }, // Huang Zhong Up
        { blockId: 'block-2', dx: 0, dy: -1 }, // Ma Chao Up
        { blockId: 'block-9', dx: 0, dy: 1 },  // Soldier Down
        { blockId: 'block-7', dx: -1, dy: 0 }, // Soldier Left
        { blockId: 'block-1', dx: 0, dy: 1 },  // Cao Cao Down
    ];
    // --- END HARDCODED SOLUTION PATH ---


    let currentBlocks = [];
    let gameWon = false;
    let isAnimating = false; // Renamed from isSolving
    let animationInterval = null;

    const boardElement = document.getElementById('klotski-board');
    const solveResetButton = document.getElementById('solve-reset-button');
    const statusElement = document.getElementById('status');

    // --- Core Game Logic (Mostly unchanged) ---

    function deepCopyBlocks(blocks) {
        return JSON.parse(JSON.stringify(blocks));
    }

    function getBlockById(blocks, id) {
        return blocks.find(b => b.id === id);
    }

    function getOccupiedGrid(blocks) {
        const grid = Array(boardHeight).fill(null).map(() => Array(boardWidth).fill(null));
        blocks.forEach(block => {
            for (let y = block.y; y < block.y + block.h; y++) {
                for (let x = block.x; x < block.x + block.w; x++) {
                    if (y < boardHeight && x < boardWidth) {
                        grid[y][x] = block.id;
                    }
                }
            }
        });
        return grid;
    }

     function isValidMove(blocks, blockId, dx, dy) {
        const block = getBlockById(blocks, blockId);
        if (!block) return false;
        const newX = block.x + dx;
        const newY = block.y + dy;

        if (newX < 0 || newX + block.w > boardWidth || newY < 0 || newY + block.h > boardHeight) {
            return false;
        }

        const occupiedGrid = getOccupiedGrid(blocks);
        for (let y = newY; y < newY + block.h; y++) {
            for (let x = newX; x < newX + block.w; x++) {
                const occupierId = occupiedGrid[y][x];
                if (occupierId !== null && occupierId !== blockId) {
                    return false;
                }
            }
        }
        return true;
    }

    // Apply move remains the same
     function applyMove(blocks, blockId, dx, dy) {
        const newBlocks = deepCopyBlocks(blocks);
        const block = getBlockById(newBlocks, blockId);
         if (block) { // Add check if block exists
             block.x += dx;
             block.y += dy;
         } else {
            console.error("Cannot apply move: Block not found - ", blockId);
         }
        return newBlocks;
    }

    // Check win condition remains the same
    function checkWinCondition(blocks) {
        const target = getBlockById(blocks, targetBlockId);
        return target && target.x === targetWinX && target.y === targetWinY;
    }

    // --- Rendering (Unchanged, checks isAnimating now) ---

    function renderBoard(blocks) {
        boardElement.innerHTML = ''; // Clear previous blocks
        blocks.forEach(block => {
            const blockDiv = document.createElement('div');
            blockDiv.id = block.id;
            blockDiv.className = `block block-${block.w}x${block.h}`;
            if (block.isTarget) {
                blockDiv.classList.add('block-target');
            }
            blockDiv.style.left = `${block.x * unitSize}px`;
            blockDiv.style.top = `${block.y * unitSize}px`;
            blockDiv.style.width = `${block.w * unitSize}px`;
            blockDiv.style.height = `${block.h * unitSize}px`;
            blockDiv.textContent = block.name || '';

            // Add click listener only if not animating and game not won
            if (!isAnimating && !gameWon) {
                 blockDiv.addEventListener('click', () => handleBlockClick(block.id));
            } else {
                blockDiv.style.cursor = 'default';
            }

            boardElement.appendChild(blockDiv);
        });

        // Check win after rendering
         const justWon = checkWinCondition(blocks);
         if(justWon && !gameWon && !isAnimating) { // Trigger win state only if not already won/animating
            gameWon = true;
            statusElement.textContent = 'Congratulations! You solved it!';
            solveResetButton.textContent = 'Reset';
         } else if (gameWon && !isAnimating) { // Ensure reset button stays if already won
             solveResetButton.textContent = 'Reset';
         }
    }

    // --- User Interaction (Unchanged) ---

    function handleBlockClick(blockId) {
        if (isAnimating || gameWon) return; // No interaction during animation or after win

        // Find the first valid single-step move into an empty adjacent space
        const possibleMoves = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ];

        for (const move of possibleMoves) {
             if (isValidMove(currentBlocks, blockId, move.dx, move.dy)) {
                 // Check if the target cell(s) are indeed empty
                 // isValidMove already confirms this, just apply the move
                 currentBlocks = applyMove(currentBlocks, blockId, move.dx, move.dy);
                 renderBoard(currentBlocks); // Re-render after move
                 break; // Only one move per click
             }
        }
    }


    // --- Play Hardcoded Solution ---

    function playHardcodedSolution() {
         if (isAnimating) return; // Prevent starting animation twice

        if (gameWon || checkWinCondition(currentBlocks)) { // If game is already won OR button says reset
            resetGame();
            return;
        }

        // Ensure puzzle is in the initial state before playing hardcoded solution
        if (JSON.stringify(currentBlocks) !== JSON.stringify(initialBlocks)) {
            // Optional: Force reset if user moved pieces? Or just play from current state?
            // Let's reset to ensure the hardcoded path is valid.
             console.log("Resetting to initial state before playing solution.");
             resetGame();
             // Need a small delay for the reset render to complete before starting animation
             setTimeout(() => {
                isAnimating = true;
                solveResetButton.disabled = true;
                solveResetButton.textContent = 'Animating...';
                statusElement.textContent = 'Playing hardcoded solution...';
                if (animationInterval) clearInterval(animationInterval);
                animateSolution(hardcodedSolutionPath);
             }, 100); // Delay of 100ms after reset
             return; // Exit function here after scheduling the animation
        }

        // If already in initial state, start animation directly
        isAnimating = true;
        solveResetButton.disabled = true;
        solveResetButton.textContent = 'Animating...';
        statusElement.textContent = 'Playing hardcoded solution...';
        if (animationInterval) clearInterval(animationInterval);
        animateSolution(hardcodedSolutionPath); // Start animation with the predefined path
    }

    // --- Animate Solution (Unchanged) ---

    function animateSolution(path) {
        let step = 0;
        if (!path || path.length === 0) {
             console.error("Cannot animate: Solution path is empty.");
             statusElement.textContent = 'Error: No solution path provided.';
             isAnimating = false;
             solveResetButton.disabled = false;
             solveResetButton.textContent = 'Show Solution';
             return;
        }

        animationInterval = setInterval(() => {
            if (step >= path.length) {
                clearInterval(animationInterval);
                animationInterval = null;
                isAnimating = false;
                gameWon = checkWinCondition(currentBlocks); // Verify win state
                statusElement.textContent = gameWon ? 'Solved!' : 'Animation finished (Check solution path if not solved).';
                solveResetButton.disabled = false;
                solveResetButton.textContent = 'Reset';
                renderBoard(currentBlocks); // Final render
                return;
            }

            const move = path[step];
            // Optional: Add validation that the move is possible from current state?
            // For hardcoded, we assume the path is correct.
             if (getBlockById(currentBlocks, move.blockId)) {
                currentBlocks = applyMove(currentBlocks, move.blockId, move.dx, move.dy);
                renderBoard(currentBlocks); // Render the move
                statusElement.textContent = `Animating step ${step + 1}/${path.length}`;
             } else {
                 console.error(`Animation Error: Block ${move.blockId} not found at step ${step}. Stopping.`);
                 clearInterval(animationInterval);
                 animationInterval = null;
                 isAnimating = false;
                 statusElement.textContent = 'Animation Error: Invalid step in path.';
                 solveResetButton.disabled = false;
                 solveResetButton.textContent = 'Reset';
                 renderBoard(currentBlocks); // Render current state
                 return;
             }
            step++;
        }, 300); // Adjust speed of animation (milliseconds per step)
    }

    // --- Initialization and Reset (Unchanged) ---

    function resetGame() {
        if (isAnimating) return; // Don't reset while animating
        if (animationInterval) clearInterval(animationInterval);

        currentBlocks = deepCopyBlocks(initialBlocks);
        gameWon = false;
        isAnimating = false;
        solveResetButton.disabled = false;
        solveResetButton.textContent = 'Show Solution'; // Button text reset
        statusElement.textContent = 'Click a block to move it or show the hardcoded solution.';
        renderBoard(currentBlocks);
    }

    // --- Event Listeners ---

    solveResetButton.addEventListener('click', playHardcodedSolution); // Button now calls playHardcodedSolution

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        resetGame(); // Initialize the board on page load
    });

</script>

</body>
</html>
