<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ÂçéÂÆπÈÅìÊ∏∏Êàè (With Solution Demo)</title>
  <style>
    /* --- Existing styles from previous version --- */
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
      overscroll-behavior-y: contain;
    }
    h1 { margin-top: 20px; }
    #board {
      width: 360px;
      height: 450px;
      margin: 20px auto;
      display: grid;
      grid-template-columns: repeat(4, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 2px;
      background-color: #444;
      position: relative;
      border: 2px solid #333;
      user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
      touch-action: none;
    }
     #controls { /* ADDED: Container for buttons */
        margin-top: 15px;
     }
     button { /* ADDED: Basic button styling */
        padding: 8px 15px;
        font-size: 16px;
        cursor: pointer;
        margin: 0 5px;
     }
     button:disabled { /* Style for disabled button */
         cursor: not-allowed;
         opacity: 0.6;
     }
    .piece {
      border-radius: 5px; font-size: 24px; font-weight: bold;
      display: flex; justify-content: center; align-items: center;
      position: absolute; transition: transform 0.1s ease-out, top 0.3s ease, left 0.3s ease; /* Added top/left transition */
      border: 1px solid rgba(0,0,0,0.2); color: white; cursor: grab;
      pointer-events: auto; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
    }
    .piece.dragging { opacity: 0.7; transform: scale(1.05); z-index: 10; }
    .piece:active { cursor: grabbing; }

    /* Sizing rules */
    .piece[data-size="2x2"] { width: 180px; height: 180px; }
    .piece[data-size="2x1"] { width: 180px; height: 90px; }
    .piece[data-size="1x2"] { width: 90px; height: 180px; }
    .piece[data-size="1x1"] { width: 90px; height: 90px; }

    /* Color rules */
    .piece[data-size="2x2"] { background-color: #e74c3c; }
    .piece[data-size="2x1"] { background-color: #2ecc71; }
    .piece[data-size="1x2"] { background-color: #3498db; }
    .piece[data-size="1x1"] { background-color: #95a5a6; }

    #board.solving { /* ADDED: Style to indicate solving state */
        cursor: wait;
    }
    #board.solving .piece {
        pointer-events: none; /* Disable interaction with pieces */
        cursor: wait;
    }

  </style>
</head>
<body>

<h1>ÂçéÂÆπÈÅìÊ∏∏Êàè</h1>
<div id="board"></div>

<div id="controls">
    <button id="resetButton">Reset</button>
    <button id="solveButton">Show Solution (Demo)</button>
</div>

<script>
  const board = document.getElementById("board");
  const solveButton = document.getElementById("solveButton");
  const resetButton = document.getElementById("resetButton");
  const gridSize = 90;

  // --- Store Initial State ---
  const initialPieces = [
    { id: "ÊõπÊìç", x: 1, y: 0, w: 2, h: 2 },
    { id: "ÂÖ≥ÁæΩ", x: 1, y: 2, w: 2, h: 1 },
    { id: "Âº†È£û", x: 0, y: 0, w: 1, h: 2 },
    { id: "Ëµµ‰∫ë", x: 3, y: 0, w: 1, h: 2 },
    { id: "È©¨Ë∂Ö", x: 0, y: 2, w: 1, h: 2 },
    { id: "ÈªÑÂø†", x: 3, y: 2, w: 1, h: 2 },
    { id: "Âçí1", x: 0, y: 4, w: 1, h: 1 },
    { id: "Âçí2", x: 1, y: 3, w: 1, h: 1 },
    { id: "Âçí3", x: 2, y: 3, w: 1, h: 1 },
    { id: "Âçí4", x: 3, y: 4, w: 1, h: 1 }
  ];

  // --- Game State (Mutable) ---
  // Use structuredClone for a deep copy to prevent mutation of initialPieces
  let pieces = structuredClone(initialPieces);

  // --- Solution Sequence (Dynamically computed using BFS) ---
  let solutionSequence = [];

  // --- State Flags ---
  let isDragging = false;
  let isSolving = false; // Flag to indicate if solution is playing
  let solutionTimeoutId = null; // To store the timeout ID for cancellation

  // --- Touch State Variables ---
  let activePieceElement = null;
  let activePieceData = null;
  let touchStartX = 0, touchStartY = 0;
  let pieceStartGridX = 0, pieceStartGridY = 0;

  // --- Helper Functions ---
  function getPieceById(id) { return pieces.find(p => p.id === id); }
  function getElementByPieceId(id) { return Array.from(board.children).find(el => el.innerText === id); }
  function createGridMap(state = pieces) { /* Use provided state or default to global pieces */
      const grid = Array.from({ length: 5 }, () => Array(4).fill(null));
      for (let p of state) {
          for (let dx = 0; dx < p.w; dx++) {
              for (let dy = 0; dy < p.h; dy++) {
                  if (p.y + dy < 5 && p.x + dx < 4) {
                      grid[p.y + dy][p.x + dx] = p.id;
                  }
              }
          }
      }
      return grid;
  }
  function isCellClear(x, y, movingPieceId, state = pieces) { /* Use provided state or default to global pieces */
      if (x < 0 || y < 0 || x >= 4 || y >= 5) return false;
      const grid = createGridMap(state);
      const occupantId = grid[y][x];
      return occupantId === null || occupantId === movingPieceId;
  }
  function canMoveTo(piece, newX, newY, state = pieces) { /* Use provided state or default to global pieces */
       if (!piece) return false;
        // 1. Boundary Check
        if (newX < 0 || newY < 0 || (newX + piece.w) > 4 || (newY + piece.h) > 5) return false;

        // 2. Check target area for obstructions
        for (let dy = 0; dy < piece.h; dy++) {
            for (let dx = 0; dx < piece.w; dx++) {
                if (!isCellClear(newX + dx, newY + dy, piece.id, state)) return false;
            }
        }

        // 3. Check path (basic single step check)
        const deltaX = newX - piece.x;
        const deltaY = newY - piece.y;
        if (Math.abs(deltaX) + Math.abs(deltaY) !== 1) {
             // Allow non-single step moves for now, but log it
             // console.warn("Move is not a single adjacent step");
             // You might want return false here for strict sliding puzzle rules
        }
        // More detailed path check (optional but better for true sliding)
        if (deltaX > 0) { // Moving right
             for(let dy = 0; dy < piece.h; dy++) if (!isCellClear(piece.x + piece.w, piece.y + dy, piece.id, state)) return false;
        } else if (deltaX < 0) { // Moving left
             for(let dy = 0; dy < piece.h; dy++) if (!isCellClear(piece.x - 1, piece.y + dy, piece.id, state)) return false;
        } else if (deltaY > 0) { // Moving down
             for(let dx = 0; dx < piece.w; dx++) if (!isCellClear(piece.x + dx, piece.y + piece.h, piece.id, state)) return false;
        } else if (deltaY < 0) { // Moving up
            for(let dx = 0; dx < piece.w; dx++) if (!isCellClear(piece.x + dx, piece.y - 1, piece.id, state)) return false;
        }
       return true;
  }

  // --- Rendering ---
  function render() {
    board.innerHTML = "";
    pieces.forEach(p => {
      const el = document.createElement("div");
      el.className = "piece";
      el.innerText = p.id;
      el.dataset.size = `${p.w}x${p.h}`;
      // Use styles for positioning to leverage CSS transitions
      el.style.width = `${p.w * gridSize}px`;
      el.style.height = `${p.h * gridSize}px`;
      el.style.left = `${p.x * gridSize}px`;
      el.style.top = `${p.y * gridSize}px`;
      el.style.transform = ''; // Reset transform

      // Draggable only if not solving
      el.draggable = !isSolving;

      board.appendChild(el);
    });
    // Update board state class
    if (isSolving) {
        board.classList.add('solving');
    } else {
        board.classList.remove('solving');
    }
  }

  // --- Move Execution ---
  function executeMove(piece, newX, newY) {
    if (!piece) {
        console.error("Attempted to move null piece");
        return false;
    }
    if (canMoveTo(piece, newX, newY)) {
      piece.x = newX;
      piece.y = newY;
      render(); // Re-render the board visually
      // Check win condition (only really relevant after manual play or full solution)
      if (piece.id === "ÊõπÊìç" && piece.x === 1 && piece.y === 3) {
          if (isSolving) { // If solved via automation
               stopSolution(); // Stop further steps if any
               setTimeout(() => alert("Solution Complete! (Reached target state)"), 100);
          } else {
               setTimeout(() => alert("ÊÅ≠ÂñúËøáÂÖ≥ÔºÅ"), 100);
          }
      }
      return true; // Move successful
    } else {
        console.warn(`Invalid move attempt: ${piece.id} to (${newX}, ${newY})`);
        return false; // Move failed
    }
  }

  // --- ADDED: Reset Function ---
  function resetBoard() {
      console.log("Resetting board...");
      stopSolution(); // Stop solution playback if running
      // Deep copy initial state back into the active state
      pieces = structuredClone(initialPieces);
      render(); // Render the reset state
      solveButton.disabled = false; // Re-enable solve button
      resetButton.disabled = false; // Ensure reset is enabled
  }

  // --- ADDED: Solution Playback Logic ---
  function playSolutionStep(stepIndex) {
      if (!isSolving || stepIndex >= solutionSequence.length) {
          console.log("Solution playback finished or stopped.");
          stopSolution(); // Ensure cleanup
          // Check if puzzle is actually solved
          const caoCao = getPieceById("ÊõπÊìç");
          if (caoCao && caoCao.x === 1 && caoCao.y === 3) {
               console.log("Solution sequence seems to have led to the goal!");
          } else {
               console.warn("Solution sequence ended, but Cao Cao not in final position.");
          }
          return;
      }

      const move = solutionSequence[stepIndex];
      const pieceToMove = getPieceById(move.id);

      console.log(`Step ${stepIndex + 1}: Moving ${move.id} to (${move.x}, ${move.y})`);

      if (!executeMove(pieceToMove, move.x, move.y)) {
            console.error(`Solution Error: Invalid move at step ${stepIndex + 1}. Halting.`);
            stopSolution();
            alert(`Solution Error: Invalid move at step ${stepIndex + 1} for ${move.id}. Playback stopped.`);
            return;
      }

      // Schedule the next step after 1 second
      solutionTimeoutId = setTimeout(() => {
          playSolutionStep(stepIndex + 1);
      }, 1000); // 1000ms = 1 second interval
  }

  /* --- NEW: Generic state ‚Üí string helper ------------------------------- */
  function encodeBoard(piecesArr) {
      // sort so that identical soldiers / tall blocks don‚Äôt permute the key
      const ordered = [...piecesArr].sort((a, b) => a.id.localeCompare(b.id));
      return ordered.map(p => `${p.x}${p.y}`).join('|');
  }

  /* --- NEW: enumerate every legal single-square slide from a position ---- */
  function* nextPositions(statePieces) {
      for (const p of statePieces) {
          // Try four directions
          const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
          for (const [dx, dy] of dirs) {
              const nx = p.x + dx, ny = p.y + dy;
              if (canMoveTo(p, nx, ny, statePieces)) {
                  // clone state & the moving piece
                  const newPieces = structuredClone(statePieces);
                  const np = newPieces.find(k => k.id === p.id);
                  np.x = nx; np.y = ny;
                  yield { pieces: newPieces, move: { id: p.id, x: nx, y: ny } };
              }
          }
      }
  }

  /* --- NEW: on-demand BFS solver ---------------------------------------- */
  function solveFromCurrentBoard() {
      const startKey = encodeBoard(pieces);
      const queue = [{ pieces: structuredClone(pieces), path: [] }];
      const seen = new Set([startKey]);

      while (queue.length) {
          const { pieces: curPieces, path } = queue.shift();
          // finish when Cao Cao reaches (1,3)
          const cao = curPieces.find(p => p.id === "ÊõπÊìç");
          if (cao.x === 1 && cao.y === 3) return path; // solved!

          for (const { pieces: nextPieces, move } of nextPositions(curPieces)) {
              const key = encodeBoard(nextPieces);
              if (!seen.has(key)) {
                  seen.add(key);
                  queue.push({ pieces: nextPieces, path: [...path, move] });
              }
          }
      }
      return null; // no solution (should never happen with a legal board)
  }

  function startSolution() {
      if (isSolving) return;

      const autoPath = solveFromCurrentBoard();
      if (!autoPath) {
          alert("I couldn't find a solution from the current position ü§î");
          return;
      }
      solutionSequence = autoPath; // replaces the old hard-coded stub
      isSolving = true;
      solveButton.disabled = true;
      resetButton.disabled = true;
      board.classList.add('solving');
      render();
      solutionTimeoutId = setTimeout(() => playSolutionStep(0), 300);
  }

  function stopSolution() {
      console.log("Stopping solution playback.");
      if (solutionTimeoutId) {
          clearTimeout(solutionTimeoutId); // Cancel scheduled next step
          solutionTimeoutId = null;
      }
      isSolving = false;
      solveButton.disabled = false; // Re-enable button
      resetButton.disabled = false;
      board.classList.remove('solving'); // Re-enable pointer events
      render(); // Update visual state
  }


  // --- Event Handlers (Interaction) ---
  function handleInteractionStart(event) {
    // IMPORTANT: Disable user interaction if solution is playing
    if (isSolving) {
        event.preventDefault();
        return;
    }

    let targetElement = event.target.closest('.piece');
    if (!targetElement || isDragging) return;

    event.preventDefault(); // Prevent defaults

    activePieceElement = targetElement;
    activePieceData = getPieceById(activePieceElement.innerText);
    if (!activePieceData) return;

    pieceStartGridX = activePieceData.x;
    pieceStartGridY = activePieceData.y;
    touchStartX = (event.touches ? event.touches[0].clientX : event.clientX);
    touchStartY = (event.touches ? event.touches[0].clientY : event.clientY);

    isDragging = true;
    activePieceElement.classList.add('dragging');

    document.addEventListener('mousemove', handleInteractionMove, { passive: false });
    document.addEventListener('touchmove', handleInteractionMove, { passive: false });
    document.addEventListener('mouseup', handleInteractionEnd);
    document.addEventListener('touchend', handleInteractionEnd);
    document.addEventListener('touchcancel', handleInteractionEnd);
    document.addEventListener('mouseleave', handleInteractionEnd);
  }

  function handleInteractionMove(event) { /* ... (same as before) ... */
      if (!isDragging || !activePieceElement) return;
      event.preventDefault();
      let currentX = (event.touches ? event.touches[0].clientX : event.clientX);
      let currentY = (event.touches ? event.touches[0].clientY : event.clientY);
      let deltaX = currentX - touchStartX;
      let deltaY = currentY - touchStartY;
      activePieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.05)`;
  }

  function handleInteractionEnd(event) { /* ... (same as before, calls executeMove) ... */
      if (!isDragging || !activePieceElement || !activePieceData) return;

      document.removeEventListener('mousemove', handleInteractionMove);
      document.removeEventListener('touchmove', handleInteractionMove);
      document.removeEventListener('mouseup', handleInteractionEnd);
      document.removeEventListener('touchend', handleInteractionEnd);
      document.removeEventListener('touchcancel', handleInteractionEnd);
      document.removeEventListener('mouseleave', handleInteractionEnd);

      let finalX = (event.changedTouches ? event.changedTouches[0].clientX : event.clientX);
      let finalY = (event.changedTouches ? event.changedTouches[0].clientY : event.clientY);
      let totalDeltaX = finalX - touchStartX;
      let totalDeltaY = finalY - touchStartY;
      const moveThreshold = 30;
      let targetX = pieceStartGridX;
      let targetY = pieceStartGridY;
      let moveAttempted = false;

      if (Math.abs(totalDeltaX) > moveThreshold || Math.abs(totalDeltaY) > moveThreshold) {
          if (Math.abs(totalDeltaX) > Math.abs(totalDeltaY)) {
              targetX += Math.sign(totalDeltaX);
          } else {
              targetY += Math.sign(totalDeltaY);
          }
          // Only execute if target is different from start
          if (targetX !== pieceStartGridX || targetY !== pieceStartGridY) {
             executeMove(activePieceData, targetX, targetY);
             moveAttempted = true; // Record that a move attempt was made
          }
      }

      // Clean up styles and state
      activePieceElement.classList.remove('dragging');
      activePieceElement.style.transform = '';

      isDragging = false;
      activePieceElement = null;
      activePieceData = null;
      // No immediate render here; executeMove handles rendering on success.
      // If the move failed or wasn't attempted, the piece visually snaps back due to CSS transition reset.
      // If snapping back needs to be instant or more controlled, uncommenting render() might be needed.
      // render();
  }


  // --- Attach Initial Listeners ---
  board.addEventListener('touchstart', handleInteractionStart, { passive: false });
  board.addEventListener('mousedown', handleInteractionStart); // Also handle mouse down

  // --- D&D Listeners (Kept for Desktop, but interaction disabled during solve) ---
   board.addEventListener('dragstart', (e) => {
        if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
        let targetElement = e.target.closest('.piece');
        if (!targetElement) { e.preventDefault(); return; }
        setTimeout(() => targetElement.style.opacity = '0.5', 0);
        e.dataTransfer.setData("text/plain", targetElement.innerText);
        e.dataTransfer.effectAllowed = "move";
   });
   board.addEventListener('dragend', (e) => {
        if (isSolving) return;
        let targetElement = e.target.closest('.piece');
        if(targetElement) targetElement.style.opacity = '1';
   });
  board.addEventListener('dragover', (e) => {
    if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
    e.preventDefault(); e.dataTransfer.dropEffect = "move";
  });
  board.addEventListener('drop', (e) => {
    if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
    e.preventDefault();
    const id = e.dataTransfer.getData("text/plain");
    const piece = getPieceById(id);
    if (!piece) return;
    const draggedElement = getElementByPieceId(id);
    if (draggedElement) draggedElement.style.opacity = '1';

    const rect = board.getBoundingClientRect();
    const dropX = e.clientX - rect.left; const dropY = e.clientY - rect.top;
    const gridX = Math.floor(dropX / gridSize); const gridY = Math.floor(dropY / gridSize);
    const deltaX = gridX - piece.x; const deltaY = gridY - piece.y;
    let targetX = piece.x; let targetY = piece.y;

    if (Math.abs(deltaX) >= Math.abs(deltaY) && deltaX !== 0) { targetX += Math.sign(deltaX); }
    else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY !== 0) { targetY += Math.sign(deltaY); }
    else { render(); return; } // No move or invalid

    executeMove(piece, targetX, targetY);
  });

  // --- ADDED: Button Listeners ---
  solveButton.addEventListener('click', startSolution);
  resetButton.addEventListener('click', resetBoard);

  // --- Initial Game Setup ---
  render(); // Draw the initial board

</script>

</body>
</html>
