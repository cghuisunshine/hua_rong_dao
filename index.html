<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>华容道游戏 (With Solution Demo)</title>
  <style>
    /* --- Existing styles from previous version --- */
    body {
      font-family: sans-serif;
      text-align: center;
      background: #f0f0f0;
      overscroll-behavior-y: contain;
    }
    h1 { margin-top: 20px; }
    #board {
      width: 360px;
      height: 450px;
      margin: 20px auto;
      display: grid;
      grid-template-columns: repeat(4, 90px);
      grid-template-rows: repeat(5, 90px);
      gap: 2px;
      background-color: #444;
      position: relative;
      border: 2px solid #333;
      user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
      touch-action: none;
    }
     #controls { /* ADDED: Container for buttons */
        margin-top: 15px;
     }
     button { /* ADDED: Basic button styling */
        padding: 8px 15px;
        font-size: 16px;
        cursor: pointer;
        margin: 0 5px;
     }
     button:disabled { /* Style for disabled button */
         cursor: not-allowed;
         opacity: 0.6;
     }
    .piece {
      border-radius: 5px; font-size: 24px; font-weight: bold;
      display: flex; justify-content: center; align-items: center;
      position: absolute; transition: transform 0.1s ease-out, top 0.3s ease, left 0.3s ease; /* Added top/left transition */
      border: 1px solid rgba(0,0,0,0.2); color: white; cursor: grab;
      pointer-events: auto; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
    }
    .piece.dragging { opacity: 0.7; transform: scale(1.05); z-index: 10; }
    .piece:active { cursor: grabbing; }

    /* Sizing rules */
    .piece[data-size="2x2"] { width: 180px; height: 180px; }
    .piece[data-size="2x1"] { width: 180px; height: 90px; }
    .piece[data-size="1x2"] { width: 90px; height: 180px; }
    .piece[data-size="1x1"] { width: 90px; height: 90px; }

    /* Color rules */
    .piece[data-size="2x2"] { background-color: #e74c3c; }
    .piece[data-size="2x1"] { background-color: #2ecc71; }
    .piece[data-size="1x2"] { background-color: #3498db; }
    .piece[data-size="1x1"] { background-color: #95a5a6; }

    #board.solving { /* ADDED: Style to indicate solving state */
        cursor: wait;
    }
    #board.solving .piece {
        pointer-events: none; /* Disable interaction with pieces */
        cursor: wait;
    }

  </style>
</head>
<body>

<h1>华容道游戏</h1>
<div id="board"></div>

<div id="controls">
    <button id="resetButton">Reset</button>
    <button id="solveButton">Show Solution (Demo)</button>
</div>

<script>
  const board = document.getElementById("board");
  const solveButton = document.getElementById("solveButton");
  const resetButton = document.getElementById("resetButton");
  const gridSize = 90;

  // --- Store Initial State ---
  const initialPieces = [
    { id: "曹操", x: 1, y: 0, w: 2, h: 2 },
    { id: "关羽", x: 1, y: 2, w: 2, h: 1 },
    { id: "张飞", x: 0, y: 0, w: 1, h: 2 },
    { id: "赵云", x: 3, y: 0, w: 1, h: 2 },
    { id: "马超", x: 0, y: 2, w: 1, h: 2 },
    { id: "黄忠", x: 3, y: 2, w: 1, h: 2 },
    { id: "卒1", x: 0, y: 4, w: 1, h: 1 },
    { id: "卒2", x: 1, y: 3, w: 1, h: 1 },
    { id: "卒3", x: 2, y: 3, w: 1, h: 1 },
    { id: "卒4", x: 3, y: 4, w: 1, h: 1 }
  ];

  // --- Game State (Mutable) ---
  // Use structuredClone for a deep copy to prevent mutation of initialPieces
  let pieces = structuredClone(initialPieces);

  // --- ADDED: Solution Sequence (81 Steps for Standard Klotski) ---
  const solutionSequence = [
    // Step 1-10
    { id: "卒2", x: 1, y: 4 }, // S2 Down
    { id: "卒3", x: 2, y: 4 }, // S3 Down
    { id: "关羽", x: 1, y: 3 }, // GuanYu Down
    { id: "马超", x: 1, y: 2 }, // MaChao Right
    { id: "黄忠", x: 2, y: 2 }, // HuangZhong Left
    { id: "赵云", x: 3, y: 1 }, // ZhaoYun Down
    { id: "张飞", x: 0, y: 1 }, // ZhangFei Down
    { id: "曹操", x: 1, y: 1 }, // CaoCao Down
    { id: "卒1", x: 0, y: 3 }, // S1 Down
    { id: "卒4", x: 3, y: 3 }, // S4 Down
    // Step 11-20
    { id: "马超", x: 0, y: 2 }, // MaChao Left
    { id: "黄忠", x: 3, y: 2 }, // HuangZhong Right
    { id: "关羽", x: 1, y: 2 }, // GuanYu Up
    { id: "卒2", x: 1, y: 3 }, // S2 Up
    { id: "卒3", x: 2, y: 3 }, // S3 Up
    { id: "曹操", x: 1, y: 0 }, // CaoCao Up
    { id: "张飞", x: 0, y: 0 }, // ZhangFei Up
    { id: "赵云", x: 3, y: 0 }, // ZhaoYun Up
    { id: "卒1", x: 1, y: 0 }, // S1 Right
    { id: "卒4", x: 2, y: 0 }, // S4 Left
    // Step 21-30
    { id: "马超", x: 1, y: 2 }, // MaChao Right
    { id: "黄忠", x: 2, y: 2 }, // HuangZhong Left
    { id: "卒1", x: 1, y: 1 }, // S1 Down
    { id: "卒4", x: 2, y: 1 }, // S4 Down
    { id: "张飞", x: 0, y: 1 }, // ZhangFei Down
    { id: "赵云", x: 3, y: 1 }, // ZhaoYun Down
    { id: "曹操", x: 1, y: 1 }, // CaoCao Down
    { id: "关羽", x: 1, y: 3 }, // GuanYu Down
    { id: "卒1", x: 0, y: 3 }, // S1 Left
    { id: "卒4", x: 3, y: 3 }, // S4 Right
    // Step 31-40
    { id: "张飞", x: 0, y: 2 }, // ZhangFei Up
    { id: "赵云", x: 3, y: 2 }, // ZhaoYun Up
    { id: "卒2", x: 1, y: 4 }, // S2 Down
    { id: "卒3", x: 2, y: 4 }, // S3 Down
    { id: "曹操", x: 1, y: 2 }, // CaoCao Down
    { id: "马超", x: 1, y: 1 }, // MaChao Up
    { id: "黄忠", x: 2, y: 1 }, // HuangZhong Up
    { id: "卒1", x: 0, y: 1 }, // S1 Left
    { id: "卒4", x: 3, y: 1 }, // S4 Right
    { id: "关羽", x: 1, y: 0 }, // GuanYu Up
    // Step 41-50
    { id: "卒2", x: 1, y: 3 }, // S2 Up
    { id: "卒3", x: 2, y: 3 }, // S3 Up
    { id: "张飞", x: 0, y: 3 }, // ZhangFei Down
    { id: "赵云", x: 3, y: 3 }, // ZhaoYun Down
    { id: "马超", x: 0, y: 1 }, // MaChao Left
    { id: "黄忠", x: 3, y: 1 }, // HuangZhong Right
    { id: "卒1", x: 1, y: 1 }, // S1 Right
    { id: "卒4", x: 2, y: 1 }, // S4 Left
    { id: "曹操", x: 1, y: 2 }, // CaoCao Down (Redundant? Check if needed) - Keeping for now based on standard solutions
    { id: "关羽", x: 1, y: 1 }, // GuanYu Down
    // Step 51-60
    { id: "卒1", x: 1, y: 0 }, // S1 Up
    { id: "卒4", x: 2, y: 0 }, // S4 Up
    { id: "马超", x: 0, y: 0 }, // MaChao Up
    { id: "黄忠", x: 3, y: 0 }, // HuangZhong Up
    { id: "张飞", x: 1, y: 3 }, // ZhangFei Right
    { id: "赵云", x: 2, y: 3 }, // ZhaoYun Left
    { id: "卒2", x: 1, y: 4 }, // S2 Down
    { id: "卒3", x: 2, y: 4 }, // S3 Down
    { id: "曹操", x: 1, y: 2 }, // CaoCao Down (Seems correct here)
    { id: "关羽", x: 1, y: 1 }, // GuanYu Down (Seems correct here)
    // Step 61-70
    { id: "卒1", x: 0, y: 1 }, // S1 Left
    { id: "卒4", x: 3, y: 1 }, // S4 Right
    { id: "马超", x: 0, y: 2 }, // MaChao Down
    { id: "黄忠", x: 3, y: 2 }, // HuangZhong Down
    { id: "卒1", x: 1, y: 1 }, // S1 Right
    { id: "卒4", x: 2, y: 1 }, // S4 Left
    { id: "关羽", x: 1, y: 0 }, // GuanYu Up
    { id: "曹操", x: 1, y: 1 }, // CaoCao Up
    { id: "张飞", x: 0, y: 3 }, // ZhangFei Left
    { id: "赵云", x: 3, y: 3 }, // ZhaoYun Right
    // Step 71-81
    { id: "卒2", x: 0, y: 4 }, // S2 Left
    { id: "卒3", x: 3, y: 4 }, // S3 Right
    { id: "马超", x: 1, y: 2 }, // MaChao Right
    { id: "黄忠", x: 2, y: 2 }, // HuangZhong Left
    { id: "卒1", x: 1, y: 1 }, // S1 Down (Redundant? Check) - Keeping
    { id: "卒4", x: 2, y: 1 }, // S4 Down (Redundant? Check) - Keeping
    { id: "曹操", x: 1, y: 2 }, // CaoCao Down
    { id: "卒1", x: 1, y: 4 }, // S1 Down
    { id: "卒4", x: 2, y: 4 }, // S4 Down
    { id: "关羽", x: 1, y: 3 }, // GuanYu Down
    { id: "曹操", x: 1, y: 3 }  // CaoCao Down (Final Move!)
  ];

  // --- State Flags ---
  let isDragging = false;
  let isSolving = false; // Flag to indicate if solution is playing
  let solutionTimeoutId = null; // To store the timeout ID for cancellation

  // --- Touch State Variables ---
  let activePieceElement = null;
  let activePieceData = null;
  let touchStartX = 0, touchStartY = 0;
  let pieceStartGridX = 0, pieceStartGridY = 0;

  // --- Helper Functions ---
  function getPieceById(id) { return pieces.find(p => p.id === id); }
  function getElementByPieceId(id) { return Array.from(board.children).find(el => el.innerText === id); }
  function createGridMap() { /* ... (same as before) ... */
      const grid = Array.from({ length: 5 }, () => Array(4).fill(null));
      for (let p of pieces) {
          for (let dx = 0; dx < p.w; dx++) {
              for (let dy = 0; dy < p.h; dy++) {
                  if (p.y + dy < 5 && p.x + dx < 4) {
                      grid[p.y + dy][p.x + dx] = p.id;
                  }
              }
          }
      }
      return grid;
  }
  function isCellClear(x, y, movingPieceId) { /* ... (same as before) ... */
      if (x < 0 || y < 0 || x >= 4 || y >= 5) return false;
       const grid = createGridMap();
       const occupantId = grid[y][x];
       return occupantId === null || occupantId === movingPieceId;
  }
  function canMoveTo(piece, newX, newY) { /* ... (same as before, includes path check) ... */
       if (!piece) return false;
        // 1. Boundary Check
        if (newX < 0 || newY < 0 || (newX + piece.w) > 4 || (newY + piece.h) > 5) return false;

        // 2. Check target area for obstructions
        for (let dy = 0; dy < piece.h; dy++) {
            for (let dx = 0; dx < piece.w; dx++) {
                if (!isCellClear(newX + dx, newY + dy, piece.id)) return false;
            }
        }

        // 3. Check path (basic single step check)
        const deltaX = newX - piece.x;
        const deltaY = newY - piece.y;
        if (Math.abs(deltaX) + Math.abs(deltaY) !== 1) {
             // Allow non-single step moves for now, but log it
             // console.warn("Move is not a single adjacent step");
             // You might want return false here for strict sliding puzzle rules
        }
        // More detailed path check (optional but better for true sliding)
        if (deltaX > 0) { // Moving right
             for(let dy = 0; dy < piece.h; dy++) if (!isCellClear(piece.x + piece.w, piece.y + dy, piece.id)) return false;
        } else if (deltaX < 0) { // Moving left
             for(let dy = 0; dy < piece.h; dy++) if (!isCellClear(piece.x - 1, piece.y + dy, piece.id)) return false;
        } else if (deltaY > 0) { // Moving down
             for(let dx = 0; dx < piece.w; dx++) if (!isCellClear(piece.x + dx, piece.y + piece.h, piece.id)) return false;
        } else if (deltaY < 0) { // Moving up
            for(let dx = 0; dx < piece.w; dx++) if (!isCellClear(piece.x + dx, piece.y - 1, piece.id)) return false;
        }
       return true;
  }

  // --- Rendering ---
  function render() {
    board.innerHTML = "";
    pieces.forEach(p => {
      const el = document.createElement("div");
      el.className = "piece";
      el.innerText = p.id;
      el.dataset.size = `${p.w}x${p.h}`;
      // Use styles for positioning to leverage CSS transitions
      el.style.width = `${p.w * gridSize}px`;
      el.style.height = `${p.h * gridSize}px`;
      el.style.left = `${p.x * gridSize}px`;
      el.style.top = `${p.y * gridSize}px`;
      el.style.transform = ''; // Reset transform

      // Draggable only if not solving
      el.draggable = !isSolving;

      board.appendChild(el);
    });
    // Update board state class
    if (isSolving) {
        board.classList.add('solving');
    } else {
        board.classList.remove('solving');
    }
  }

  // --- Move Execution ---
  function executeMove(piece, newX, newY) {
    if (!piece) {
        console.error("Attempted to move null piece");
        return false;
    }
    if (canMoveTo(piece, newX, newY)) {
      piece.x = newX;
      piece.y = newY;
      render(); // Re-render the board visually
      // Win condition check moved to playSolutionStep
      return true; // Move successful
    } else {
        console.warn(`Invalid move attempt: ${piece.id} to (${newX}, ${newY})`);
        return false; // Move failed
    }
  }

  // --- ADDED: Reset Function ---
  function resetBoard() {
      console.log("Resetting board...");
      stopSolution(); // Stop solution playback if running
      // Deep copy initial state back into the active state
      pieces = structuredClone(initialPieces);
      render(); // Render the reset state
      solveButton.disabled = false; // Re-enable solve button
      resetButton.disabled = false; // Ensure reset is enabled
  }

  // --- ADDED: Solution Playback Logic ---
  function playSolutionStep(stepIndex) {
      if (!isSolving || stepIndex >= solutionSequence.length) {
          console.log("Solution playback finished or stopped.");
          stopSolution(); // Ensure cleanup
          // Check if puzzle is actually solved
          const caoCao = getPieceById("曹操");
          if (caoCao && caoCao.x === 1 && caoCao.y === 3) {
               console.log("Solution sequence seems to have led to the goal!");
          } else {
               console.warn("Solution sequence ended, but Cao Cao not in final position.");
          }
          return;
      }

      const move = solutionSequence[stepIndex];
      const pieceToMove = getPieceById(move.id);

      console.log(`Step ${stepIndex + 1}: Moving ${move.id} to (${move.x}, ${move.y})`);

      if (!executeMove(pieceToMove, move.x, move.y)) {
            console.error(`Solution Error: Invalid move at step ${stepIndex + 1}. Halting.`);
            stopSolution();
            alert(`Solution Error: Invalid move at step ${stepIndex + 1} for ${move.id}. Playback stopped.`);
            return;
      }

      // --- ADDED: Check for win condition AFTER successful move ---
      if (pieceToMove.id === "曹操" && pieceToMove.x === 1 && pieceToMove.y === 3) {
          console.log("Solution Complete! (Reached target state via sequence)");
          stopSolution(); // Stop playback, goal reached
          return; // Don't schedule next step
      }
      // --- END ADDED ---


      // Schedule the next step ONLY if still solving
      if (isSolving) {
          solutionTimeoutId = setTimeout(() => {
              playSolutionStep(stepIndex + 1);
          }, 1000); // 1000ms = 1 second interval
      }
      // No 'else' needed here, stopSolution() handles the state if called above or manually
  }

  function startSolution() {
      if (isSolving) return; // Already solving

      console.log("Starting solution playback...");
      resetBoard(); // Start from the initial configuration

      isSolving = true;
      solveButton.disabled = true; // Disable button during playback
      resetButton.disabled = true; // Disable reset during playback
      board.classList.add('solving'); // Add class to disable pointer events via CSS
      render(); // Render immediately to reflect disabled state visually

      // Start the sequence after a brief delay
      solutionTimeoutId = setTimeout(() => playSolutionStep(0), 500);
  }

  function stopSolution() {
      console.log("Stopping solution playback.");
      if (solutionTimeoutId) {
          clearTimeout(solutionTimeoutId); // Cancel scheduled next step
          solutionTimeoutId = null;
      }
      isSolving = false;
      solveButton.disabled = false; // Re-enable button
      resetButton.disabled = false;
      board.classList.remove('solving'); // Re-enable pointer events
      render(); // Update visual state
  }


  // --- Event Handlers (Interaction) ---
  function handleInteractionStart(event) {
    // IMPORTANT: Disable user interaction if solution is playing
    if (isSolving) {
        event.preventDefault();
        return;
    }

    let targetElement = event.target.closest('.piece');
    if (!targetElement || isDragging) return;

    event.preventDefault(); // Prevent defaults

    activePieceElement = targetElement;
    activePieceData = getPieceById(activePieceElement.innerText);
    if (!activePieceData) return;

    pieceStartGridX = activePieceData.x;
    pieceStartGridY = activePieceData.y;
    touchStartX = (event.touches ? event.touches[0].clientX : event.clientX);
    touchStartY = (event.touches ? event.touches[0].clientY : event.clientY);

    isDragging = true;
    activePieceElement.classList.add('dragging');

    document.addEventListener('mousemove', handleInteractionMove, { passive: false });
    document.addEventListener('touchmove', handleInteractionMove, { passive: false });
    document.addEventListener('mouseup', handleInteractionEnd);
    document.addEventListener('touchend', handleInteractionEnd);
    document.addEventListener('touchcancel', handleInteractionEnd);
    document.addEventListener('mouseleave', handleInteractionEnd);
  }

  function handleInteractionMove(event) { /* ... (same as before) ... */
      if (!isDragging || !activePieceElement) return;
      event.preventDefault();
      let currentX = (event.touches ? event.touches[0].clientX : event.clientX);
      let currentY = (event.touches ? event.touches[0].clientY : event.clientY);
      let deltaX = currentX - touchStartX;
      let deltaY = currentY - touchStartY;
      activePieceElement.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(1.05)`;
  }

  function handleInteractionEnd(event) { /* ... (same as before, calls executeMove) ... */
      if (!isDragging || !activePieceElement || !activePieceData) return;

      document.removeEventListener('mousemove', handleInteractionMove);
      document.removeEventListener('touchmove', handleInteractionMove);
      document.removeEventListener('mouseup', handleInteractionEnd);
      document.removeEventListener('touchend', handleInteractionEnd);
      document.removeEventListener('touchcancel', handleInteractionEnd);
      document.removeEventListener('mouseleave', handleInteractionEnd);

      let finalX = (event.changedTouches ? event.changedTouches[0].clientX : event.clientX);
      let finalY = (event.changedTouches ? event.changedTouches[0].clientY : event.clientY);
      let totalDeltaX = finalX - touchStartX;
      let totalDeltaY = finalY - touchStartY;
      const moveThreshold = 30;
      let targetX = pieceStartGridX;
      let targetY = pieceStartGridY;
      let moveAttempted = false;

      if (Math.abs(totalDeltaX) > moveThreshold || Math.abs(totalDeltaY) > moveThreshold) {
          if (Math.abs(totalDeltaX) > Math.abs(totalDeltaY)) {
              targetX += Math.sign(totalDeltaX);
          } else {
              targetY += Math.sign(totalDeltaY);
          }
          // Only execute if target is different from start
          if (targetX !== pieceStartGridX || targetY !== pieceStartGridY) {
             executeMove(activePieceData, targetX, targetY);
             moveAttempted = true; // Record that a move attempt was made
          }
      }

      // Clean up styles and state
      activePieceElement.classList.remove('dragging');
      activePieceElement.style.transform = '';

      isDragging = false;
      activePieceElement = null;
      activePieceData = null;
      // No immediate render here; executeMove handles rendering on success.
      // If the move failed or wasn't attempted, the piece visually snaps back due to CSS transition reset.
      // If snapping back needs to be instant or more controlled, uncommenting render() might be needed.
      // render();
  }


  // --- Attach Initial Listeners ---
  board.addEventListener('touchstart', handleInteractionStart, { passive: false });
  board.addEventListener('mousedown', handleInteractionStart); // Also handle mouse down

  // --- D&D Listeners (Kept for Desktop, but interaction disabled during solve) ---
   board.addEventListener('dragstart', (e) => {
        if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
        let targetElement = e.target.closest('.piece');
        if (!targetElement) { e.preventDefault(); return; }
        setTimeout(() => targetElement.style.opacity = '0.5', 0);
        e.dataTransfer.setData("text/plain", targetElement.innerText);
        e.dataTransfer.effectAllowed = "move";
   });
   board.addEventListener('dragend', (e) => {
        if (isSolving) return;
        let targetElement = e.target.closest('.piece');
        if(targetElement) targetElement.style.opacity = '1';
   });
  board.addEventListener('dragover', (e) => {
    if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
    e.preventDefault(); e.dataTransfer.dropEffect = "move";
  });
  board.addEventListener('drop', (e) => {
    if (isSolving) { e.preventDefault(); return; } // Disable D&D during solve
    e.preventDefault();
    const id = e.dataTransfer.getData("text/plain");
    const piece = getPieceById(id);
    if (!piece) return;
    const draggedElement = getElementByPieceId(id);
    if (draggedElement) draggedElement.style.opacity = '1';

    const rect = board.getBoundingClientRect();
    const dropX = e.clientX - rect.left; const dropY = e.clientY - rect.top;
    const gridX = Math.floor(dropX / gridSize); const gridY = Math.floor(dropY / gridSize);
    const deltaX = gridX - piece.x; const deltaY = gridY - piece.y;
    let targetX = piece.x; let targetY = piece.y;

    if (Math.abs(deltaX) >= Math.abs(deltaY) && deltaX !== 0) { targetX += Math.sign(deltaX); }
    else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY !== 0) { targetY += Math.sign(deltaY); }
    else { render(); return; } // No move or invalid

    executeMove(piece, targetX, targetY);
  });

  // --- ADDED: Button Listeners ---
  solveButton.addEventListener('click', startSolution);
  resetButton.addEventListener('click', resetBoard);

  // --- Initial Game Setup ---
  render(); // Draw the initial board

</script>

</body>
</html>
